1. 描述一下epoll和select
	A. select和epoll本质上是IO多路复用模型，以select为例，不同于IO阻塞模型，进程阻塞于IO调用函数，IO复用模型阻塞于select调用，等待数据报套接字变为可读，当返回可读时再使用IO函数将数据报复制到应用进程缓冲区，使用select的优势在于可以等待多个描述符就绪。select告知内核我们对哪些描述符（读，写或异常条件）感兴趣以及等待多长时间，每次调用前需要将描述符集内所关心的位置为1.select的缺点在于：1.监听的描述符有限（#define __FD_SETSIZE    1024）；2.select返回了整个描述符的数组，需要轮询整个数组才能判断就绪的描述符；3.从内核到用户空间，需要复制大量的句柄数据结构，产生大的开销。poll使用链表存储文件描述符，因此没有了监听描述符的数量限制，其他缺点仍然存在。
	B. epoll没有最大文件描述符数量的限制，通过epoll_ctl函数添加进来的事件都会被放在红黑树的某个节点内，当相应的事件发生后，就会调用这个回调函数，该回调函数在内核中被称为：ep_poll_callback,这个回调函数其实就所把这个事件添加到rdllist这个双向链表中。一旦有事件发生，epoll就会将该事件添加到双向链表中。那么当我们调用epoll_wait时，epoll_wait只需要检查rdlist双向链表中是否有存在注册的事件，效率非常可观。这里也需要将发生了的事件复制到用户态内存中即可。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。
	C. 水平触发和边缘触发。水平触发（LT）：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况；边缘触发（ET）：只会通知一次，需要配合非阻塞IO使用。
	D. 参考：https://www.cnblogs.com/lojunren/p/3856290.html

2. squid中是如何使用epoll的？
	A. 使用fd_table表格来管理所使用的fd，fde结构体包括了fd信息及各个回调函数等
	B. comm_select_init中epoll_create
	C. clientHttpConnectionsOpen，将端口打开，listen，添加httpAccept等回调函数，设置epoll_ctl，httpAccept函数中，执行comm_accept.
	D. for循环，do_comm_select，epoll_wait，调用回调函数

3. 阻塞，非阻塞，异步，同步的区别？
	A. 同步：执行一个操作之后，等待结果，然后才继续执行后续的操作。
		异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的			操作。
		阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。
		非阻塞：进程给CPU传达任我后，继续处理后续的操作，隔断时间再来询问之前的操作是否			完成。这样的过程其实也叫轮询。
  	阻塞、非阻塞、多路IO复用，都是同步IO，异步必定是非阻塞的，所以不存在异步阻塞和异步非阻塞的说法。真正的异步IO需要CPU的深度参与。换句话说，只有用户线程在操作IO的时候根本不去考虑IO的执行全部都交给CPU去完成，而自己只等待一个完成信号的时候，才是真正的异步IO。所以，拉一个子线程去轮询、去死循环，或者使用select、poll、epool，都不是异步。
